# -*- coding: utf-8 -*-
"""CS103 Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l1dsxd7BM-10NgEhMB8Q-S8ENExwzzqr
"""

!pip install cs103

"""# **PROJECT: FINDING AVERAGE STUDENT DEBT BY LOCATION**

By: Grace Tu 67641977

## **PLANNING**

*   The student debt csv data file is from the Government of Canada's Website. The files contains information on student debt with the:
 - reference date
 - geographic location
 - level of study 
 - information source
 - statistic type 
 - debt amount in CAD (there are many missing data in this section)
*   Goal: Create a bar chart of the average student debt owed to any student loan source at time of graduation for students with Bachelor's degree for each province, compared with the national average
* The information needed from the csv file to achieve my goal include: 
  - GEO: the location will be plotted on the x-axis
  - LEVEL: the level of study is needed to filter debt for "Bachelor's"
  - SOURCE: source is needed to filter to only the category "...owed money...to any source".
  - STATS: stats is needed to filter to only the category "average debt owed ...at time of graduation" to standardize the results.
  - VALUE: value is amount of student debt which will be plotted on the y-axis

## **CODE**
"""

### DATA DEFINITIONS ###

from cs103 import *
from typing import NamedTuple, List
from enum import Enum

Source = Enum('Source', ['gov', 'non_gov', 'any'])
#interp. a source is either the government student loan program ('gov'), non-government source ('non_gov'),
#or either the government or non-government source ('any').

#examples are redundant for enumeration

@typecheck
#template from One of (3 cases) and atomic distinct (3 times)
def fn_for_source(s:Source) -> ...:
    if s == Source.gov:
        return ...
    elif s == Source.non_gov:
        return ...
    elif s == Source.any:
        return ...
    
Stat = Enum('Stat', ['pct_grd', 'pct_lrg', 'pct_paid', 'avg_grd', 'avg_intv'])
#interp. a stat is either the percent of graduates owing debt ('pct_grd'), the percent of graduates with 
#large debt(>=$25k) at graduation ('pct_lrg'), the percent of graduates who paid off the debt at interview ('pct_paid'),
#the average debt at graduation ('avg_grd') in CAD, or the average debt at interview ('avg_intv') in CAD.

#examples are redundant for enumeration

@typecheck
#template from One of (5 cases) and atomic distinct (5 times)
def fn_for_stat(s:Stat) -> ...:
    if s == Stat.pct_grd:
        return ...
    elif s == Stat.pct_lrg:
        return ...
    elif s == Stat.pct_paid:
        return ...
    elif s == Stat.avg_grd:
        return ...
    elif s == Stat.avg_intv:
        return ...

StudentDebt = NamedTuple('StudentDebt', [('geo', str),
                                         ('lvl', str),
                                         ('source', Source),
                                         ('stat', Stat),
                                         ('amt', int)]) #in range [0, ...)
#interp. student debt with its location ('geo'), level of study ('lvl'), debt source, type of 
#statistic ('stat'), and amount ('amt').

SD1 = StudentDebt('Canada', 'College', Source.gov, Stat.pct_grd, 56)
SD2 = StudentDebt('Canada', "Bachelor's", Source.any, Stat.avg_grd, 34000)
SD3 = StudentDebt('Alberta', "Bachelor's", Source.any, Stat.avg_grd, 12600)
SD4 = StudentDebt('British Columbia', "Master's", Source.non_gov, Stat.pct_paid, 43)
SD5 = StudentDebt('Ontario', 'Doctorate', Source.any, Stat.avg_intv, 18950)
SD6 = StudentDebt('Quebec', "Bachelor's", Source.any, Stat.avg_grd, 31020)

@typecheck
#template based on Compound (5 fields) and Reference (twice)
def fn_for_student_debt(sd: StudentDebt) -> ...:
    return ...(sd.geo,
               sd.lvl,
               fn_for_source(sd.source),
               fn_for_stat(sd.stat),
               sd.amt)

# List[StudentDebt]
# interp. a list of StudentDebts

LOSD0 = []
LOSD1 = [SD1]
LOSD2 = [SD1, SD2, SD3]
LOSD3 = [SD3, SD4, SD1, SD2]

@typecheck
#template from Arbitrary-sized and Reference rule
def fn_for_losd(losd: List[StudentDebt]) -> ...:
    # description of the acc
    acc = ... # type: ...
    for sd in losd:
        acc = ...(acc, fn_for_student_debt(sd))
    return ...(acc)

from google.colab import files 
  
  
files.upload()

### FUNCTIONS ###

import csv
from matplotlib import pyplot as plt

@typecheck
def main(filename: str) -> None:
    """
    Reads the file from given filename, plots a bar chart of average student debt in CAD by location, 
    and return None.
    """
    #return None #stub
    # Template from HtDAP, based on function composition 
    return plot_avg_debt_by_geo(read(filename))

@typecheck
def plot_avg_debt_by_geo(losd:List[StudentDebt]) -> None:
    """
    Display a bar chart showing the average student debt in CAD by geographic location and returns None.
    The locations include Canada as a whole and its 10 Provinces.
    """
    #return None #stub
    # Template based on visualization
    
    # set values for the x-axis and y-axis, respectively
    geos = geo_locations(losd)
    averages = list_of_avg_valid_debt(geos, losd)     

    # set the labels for the x-axis, y-axis, and plot title
    plt.xlabel('Geographic Location')
    plt.ylabel('Average Student Debt (in CAD)')
    plt.title('Average Student Debt by Location')
    
    # create the bar chart
    plt.bar(tick_locations(geos), averages, 8, alpha=0.3, color='g')
    
    # set ticks
    plt.xticks(tick_locations(geos), geos, rotation=30, horizontalalignment='right')
    
    # set the range for y-axis
    plt.ylim(0, 35000)
    
    # show the plot
    plt.show()
    
    return None

@typecheck
def tick_locations(los: List[str]) -> List[int]:
    """
    returns the tick locations as intervals of 10s starting at 5 based on the number of items in los.
    """
    #return [] #stub
    #template from List[str]
    
    # acc stores the tick locations so far
    acc = [] # type: List[int]
    #next_num stores the next number in the list
    next_num = 5 #type: int
    for s in los:
        acc.append(next_num)
        next_num = next_num + 10
    return acc

@typecheck
def read(filename: str) -> List[StudentDebt]:
    """    
    reads information from the specified file and returns a list of student debt. If the student debt
    amount is missing, skips that row and goes to the next line in the file.
    """
    #return []  #stub
    # Template from HtDAP
    # losd contains the result (i.e. student debts) so far
    losd = [] # type: List[StudentDebt]

    with open(filename) as csvfile:
        
        reader = csv.reader(csvfile)
        next(reader) # skip header line

        for row in reader:
            if is_valid(row[5]):
                sd = StudentDebt(row[1],row[2],source_type(row[3]),stat_type(row[4]),parse_int(row[5]))
                losd.append(sd)
    
    return losd

@typecheck
def is_valid(s:str) -> bool:
    """
    return True if s can be parsed into an integer, False otherwise. 
    """
    #return True #stub
    #return ...(s) #template
    return parse_int(s) != None

@typecheck
def source_type(s:str) -> Source: 
    """
    returns the student debt source type for given s.
    """
    #return Source.gov #stub
    #return ...(s) #template
    if s == "Graduates who owed money for their education to government student loan programs":
        return Source.gov
    elif s == "Graduates who owed money for their education to non-government sources":
        return Source.non_gov
    elif s == "Graduates who owed money for their education to any source (government or non-government)":
        return Source.any

@typecheck
def stat_type(s:str) -> Stat: 
    """
    returns the student debt statistic type for given s.
    """
    #return Stat.avg_grd #stub
    #return ...(s) #template 
    if s == "Percentage of graduates who owed debt to the source":
        return Stat.pct_grd
    elif s == "Percentage of graduates with large debt at graduation ($25,000 and over)":
        return Stat.pct_lrg
    elif s == "Percentage of graduates with debt who had paid it off  at time of interview":
        return Stat.pct_paid
    elif s == "Average debt owed to the source at time of graduation (dollars)":
        return Stat.avg_grd
    elif s == "Average debt remaining at time of interview for those who still owed (dollars)":
        return Stat.avg_intv

@typecheck
def list_of_avg_valid_debt(los: List[str], losd: List[StudentDebt]) -> List[float]:
    """
    returns the list of average student debts from losd in each of the geographical locations
    from los that are valid (i.e. from any source, uses the average debt at graduation as the 
    stat, and is from a Bachelor's degree); if the list of valid StudentDebts for a geo is empty, 
    then that average is returned as 0.0
    """
    #Plan:
    # 1. filter list to only Stat.avg_grd, Source.any, and "Bachelors" *DONE*
    # 2. average student debt for each location *DONE*
    # 3. return a list of those averages *DONE*
    
    #return [] #stub
    #template based on Composition
    return list_of_avg(los, filter_valid_debt(losd))

@typecheck
def list_of_avg(los: List[str], losd: List[StudentDebt]) -> List[float]:
    """
    returns the list of average student debts from losd in each of the geographical locations
    ('geo') from los; if the list of StudentDebts for a geo is empty, then that average is 0.0
    """
    #return [] #stub
    #template from List[str] with additional parameter
    #acc stores the average debts for the locations in los seen so far
    acc = [] # type: List[float]
    for geo in los:
        acc.append(avg_debt_in_geo(losd, geo))
    return acc

@typecheck
def avg_debt_in_geo(losd: List[StudentDebt], geo:str) -> float:
    """ 
    returns the average (mean) of the debt amounts from given geo in losd; if the list 
    of student debts from the given geo is empty, return 0.0
    """ 
    #return 0.0 #stub
    #template based on Composition 
    return average(filter_geo(losd, geo))   

@typecheck
def average(losd: List[StudentDebt]) -> float:
    """
    returns the average (mean) of the debt amounts in losd; if losd is an empty list, 
    return 0.0
    """
    #return 0.0 #stub
    #template from List[StudentDebt]
    if len(losd) == 0:
        return 0.0
    # acc stores the sum of the debt from losd seen so far
    acc = 0 # type: int
    for sd in losd:
        acc = acc + sd.amt
    return acc/len(losd)

@typecheck
def filter_geo(losd: List[StudentDebt], geo:str) -> List[StudentDebt]:
    """
    return a list of student debts that are from the given geo in losd.
    """
    #return [] #stub 
    #template from List[StudentDebt] with additional parameter
    # acc stores the StudentDebts in geo from losd seen so far
    acc = [] # type: List[StudentDebt]
    for sd in losd:
        if is_given_geo(sd, geo):
            acc.append(sd)
    return acc

@typecheck
def is_given_geo(sd:StudentDebt, geo:str) -> bool:
    """
    returns True if sd's geographic location is the same as given geo, False otherwise.
    """
    #return True #stub
    #template from StudentDebt with additional parameter
    return sd.geo == geo

@typecheck
def filter_valid_debt(losd: List[StudentDebt]) -> List[StudentDebt]:
    """
    return a list of student debts that are of the valid source type (any), valid stat type (avg_grd), 
    and valid level of study ("Bachelor's") from losd.
    """
    #return [] #stub
    #template from List[StudentDebt]
    # acc stores the StudentDebts that are valid from losd seen so far
    acc = [] # type: List[StudentDebt]
    for sd in losd:
        if is_valid_bachelor_debt(sd):
            acc.append(sd)
    return acc
    
@typecheck
def is_valid_bachelor_debt(sd:StudentDebt) -> bool:
    """
    returns True if sd's stat is avg_grd, sd's source is any, and sd's level of study is "Bachelor's",
    False otherwise
    """
    #return True #stub
    #template treats sd as atomic instead of compound
    #return ...(sd) #template
    return is_valid_stat(sd) and is_valid_source(sd) and is_bachelor(sd)

@typecheck
def is_valid_stat(sd:StudentDebt) -> bool:
    """
    returns True if sd's stat is avg_grd (i.e. Average debt owed to the source at time of graduation), 
    False otherwise.
    """
    #return True #stub
    #template from StudentDebt
    return is_avg_grd(sd.stat)

@typecheck
def is_avg_grd(s:Stat) -> bool:
    """
    returns True if s is Stat.avg_grd (i.e. Average debt owed to the source at time of graduation),
    False otherwise.
    """
    #return True #stub
    #template from Stat
    if s == Stat.pct_grd:
        return False
    elif s == Stat.pct_lrg:
        return False
    elif s == Stat.pct_paid:
        return False
    elif s == Stat.avg_grd:
        return True
    elif s == Stat.avg_intv:
        return False    

@typecheck
def is_valid_source(sd:StudentDebt) -> bool:
    """
    returns True if sd's source is any (i.e. owed money to government or non-government), 
    False otherwise.
    """
    #return True #stub
    #template from StudentDebt
    return is_any_source(sd.source)

@typecheck
def is_any_source(s:Source) -> bool:
    """
    returns True if s is Source.any (i.e. government or non-government), False otherwise.
    """
    #return True #stub
    #template from Source
    if s == Source.gov:
        return False
    elif s == Source.non_gov:
        return False
    elif s == Source.any:
        return True

@typecheck
def is_bachelor(sd:StudentDebt) -> bool:
    """
    returns True if sd's level of study is "Bachelor's", False otherwise.
    """
    #return True #stub
    #template from StudentDebt
    return sd.lvl == "Bachelor's"

@typecheck
def geo_locations(losd: List[StudentDebt]) -> List[str]:
    """
    Returns the list of unique geographic locations (i.e. 'Canada' + Provinces) from losd.
    """
    #return [] #stub
    #template from List[StudentDebt]
    acc = [] # type: List[str]
    for sd in losd:
        if new_geo(acc, sd):
            acc.append(sd.geo)
    return acc
   
@typecheck
def new_geo(los: List[str], sd: StudentDebt) -> bool:
    """
    return True if sd's geographical location is not found in los, False otherwise.
    """
    #return True #stub
    #template from StudentDebt with addtional parameter
    return not sd.geo in los

start_testing()

SD1 = StudentDebt('Canada', 'College', Source.gov, Stat.pct_grd, 56)
SD2 = StudentDebt('Canada', "Bachelor's", Source.any, Stat.avg_grd, 34000)
SD3 = StudentDebt('Alberta', "Bachelor's", Source.any, Stat.avg_grd, 12600)
SD4 = StudentDebt('British Columbia', "Master's", Source.non_gov, Stat.pct_paid, 43)
SD5 = StudentDebt('Ontario', 'Doctorate', Source.any, Stat.avg_intv, 18950)
SD6 = StudentDebt('Quebec', "Bachelor's", Source.any, Stat.avg_grd, 31020)
SD7 = StudentDebt('Alberta', "Bachelor's", Source.gov, Stat.avg_grd, 20300)
LOSD = [SD1, SD2, SD3, SD4, SD5, SD6, SD7]

# Examples and tests for main
expect(main("student_debt_by_province_and_level_of_study_empty_test.csv"), None)
#should produce an empty graph with x axis 'Geographic Location', y axis 'Average Student Debt (in CAD)',
#and title 'Average Student Debt by Location'
expect(main("student_debt_by_province_and_level_of_study_test_1.csv"), None)
# graph should look vaguely like this, with the same title/labels described above:
# 35000   |
#         |                * 
#         |                *        
# 25000   |                *        
#         |                *          
#         |                *                  
# 15000   |                *          
#         |                *          
#         |                *          
# 5000    |                *          
#         |                *          
#         +--------------------------------
#             ada      Labrador     ario       
#          Can        and         Ont       
#              Newfoundland
expect(main("student_debt_by_province_and_level_of_study_test_2.csv"), None)
# graph should look vaguely like this, with the same title/labels described above:
# 35000   |
#         |                 
#         |                        
# 25000   |                        
#         |                          
#         |                                  
# 15000   |                          
#         |                          
#         |                          
# 5000    |                          
#         |                          
#         +--------------------------------
#             bec       ario       erta
#          Que       Ont        Alb
expect(main("student_debt_by_province_and_level_of_study_test_3.csv"), None)
# graph should look vaguely like this, with the same title/labels described above:
# 35000   |
#         |    *               
#         |    *                     
# 25000   |    *                     
#         |    *                       
#         |    *                       *        
# 15000   |    *                       *
#         |    *                       *
#         |    *                       *
# 5000    |    *                       *
#         |    *                       *
#         +------------------------------------
#           Island       erta       Columbia
#       Edward        Alb        British
#   Prince

expect(tick_locations([]), [])
expect(tick_locations(['Canada', 'Ontario', 'Quebec', 'BC']), [5, 15, 25, 35])
expect(tick_locations(geo_locations(LOSD)), [5, 15, 25, 35, 45])


expect(plot_avg_debt_by_geo([]), None)
#should produce an empty graph with x axis 'Geographic Location', y axis 'Average Student Debt (in CAD)',
#and title 'Average Student Debt by Location'
expect(plot_avg_debt_by_geo(LOSD), None)
#see drawing in the *Markdown* cell below this code
expect(plot_avg_debt_by_geo([StudentDebt('Newfoundland and Labrador', "Bachelor's", Source.any, Stat.avg_grd, 32700),
                             StudentDebt('Quebec', "Bachelor's", Source.any, Stat.avg_grd, 25000),
                             StudentDebt('Quebec', "Bachelor's", Source.any, Stat.avg_grd, 48700),
                             StudentDebt('Quebec', "Doctorate", Source.any, Stat.pct_grd, 30),
                             StudentDebt('Quebec', "Bachelor's", Source.any, Stat.avg_grd, 12700),
                             StudentDebt('Manitoba', "Bachelor's", Source.any, Stat.avg_grd, 22490),
                             StudentDebt('Newfoundland and Labrador', "Bachelor's", Source.any, Stat.avg_grd, 34298)]), 
       None)
# graph should look vaguely like this, with the same title/labels described above:
# 35000   |
#         |   *
#         |   *         *         
# 25000   |   *         *         
#         |   *         *         *
#         |   *         *         *        
# 15000   |   *         *         *
#         |   *         *         *
#         |   *         *         *
# 5000    |   *         *         *
#         |   *         *         *
#         +--------------------------------
#          Labrador    bec       toba
#         and       Que       Mani
#  Newfoundland
    
summary()

start_testing()

# Examples and tests for read 
expect(read("student_debt_by_province_and_level_of_study_empty_test.csv"), [])
expect(read("student_debt_by_province_and_level_of_study_test_1.csv"), 
           [StudentDebt('Canada', 'College', Source.any, Stat.pct_lrg, 16),
            StudentDebt('Canada', 'College', Source.any, Stat.avg_grd, 12700),
            StudentDebt('Canada', 'College', Source.any, Stat.avg_grd, 13600),
            StudentDebt('Newfoundland and Labrador', "Bachelor's", Source.any, Stat.avg_grd, 32700),
            StudentDebt('Ontario', 'Doctorate', Source.gov, Stat.avg_grd, 28700)])
expect(read("student_debt_by_province_and_level_of_study_test_2.csv"),
       [StudentDebt('Quebec', 'College', Source.gov, Stat.pct_paid, 23),
        StudentDebt('Quebec', 'College', Source.gov, Stat.avg_intv, 6600),
        StudentDebt('Ontario', "Bachelor's", Source.any, Stat.avg_intv, 21900),
        StudentDebt('Ontario', "Bachelor's", Source.gov, Stat.avg_grd, 19400),
        StudentDebt('Alberta', 'Doctorate', Source.non_gov, Stat.avg_intv, 20000)])
expect(read("student_debt_by_province_and_level_of_study_test_3.csv"),
       [StudentDebt('Prince Edward Island', "Bachelor's", Source.any, Stat.avg_grd, 29500),
        StudentDebt('Prince Edward Island', "Bachelor's", Source.any, Stat.avg_grd, 36500),
        StudentDebt('Alberta', "Bachelor's", Source.any, Stat.avg_intv, 19100),
        StudentDebt('British Columbia', "Bachelor's", Source.any, Stat.avg_grd, 20700)])
expect(read("student_debt_by_province_and_level_of_study_test_4.csv"),
      [StudentDebt('Saskatchewan',"Bachelor's", Source.non_gov, Stat.avg_intv, 17400),
       StudentDebt('Saskatchewan',"Master's", Source.any, Stat.pct_grd, 42)])

# Examples and tests for is_valid
expect(is_valid(''), False)
expect(is_valid('x'), False)
expect(is_valid('F'), False)
expect(is_valid('80'), True)
expect(is_valid('0.0'), False)

# Examples and tests for source_type
expect(source_type("Graduates who owed money for their education to government student loan programs"), Source.gov)
expect(source_type("Graduates who owed money for their education to non-government sources"), Source.non_gov)
expect(source_type("Graduates who owed money for their education to any source (government or non-government)"), Source.any)

# Examples and tests for stat_type
expect(stat_type("Percentage of graduates who owed debt to the source"), Stat.pct_grd)
expect(stat_type("Percentage of graduates with large debt at graduation ($25,000 and over)"), Stat.pct_lrg)
expect(stat_type("Percentage of graduates with debt who had paid it off  at time of interview"), Stat.pct_paid)
expect(stat_type("Average debt owed to the source at time of graduation (dollars)"), Stat.avg_grd)
expect(stat_type("Average debt remaining at time of interview for those who still owed (dollars)"), Stat.avg_intv)

summary()

start_testing()

# Examples and tests for list_of_avg_valid_debt and helpers
expect(list_of_avg_valid_debt([], []), [])
expect(list_of_avg_valid_debt(['Manitoba', 'Nova Scotia'], LOSD), [0.0, 0.0])
expect(list_of_avg_valid_debt(['Canada', 'Alberta', 'Ontario', 'Quebec'], 
                              LOSD), [34000, 12600, 0.0, 31020])
expect(list_of_avg_valid_debt(['Saskatchewan', 'Canada', 'Prince Edward Island', 'Alberta', 'Ontario'], 
                              [StudentDebt('Canada', 'College', Source.any, Stat.pct_lrg, 16),
                               StudentDebt('Canada', "Bachelor's", Source.any, Stat.avg_grd, 12700),
                               StudentDebt('Canada', 'College', Source.any, Stat.avg_grd, 13600),
                               StudentDebt('Alberta', "Bachelor's", Source.any, Stat.avg_intv, 19100),
                               StudentDebt('Saskatchewan',"Bachelor's", Source.non_gov, Stat.avg_intv, 17400),
                               StudentDebt('Saskatchewan',"Master's", Source.any, Stat.pct_grd, 42),
                               StudentDebt('Ontario', 'Doctorate', Source.gov, Stat.avg_grd, 28700),
                               StudentDebt('Prince Edward Island', "Bachelor's", Source.any, Stat.avg_grd, 29500),
                               StudentDebt('Prince Edward Island', "Bachelor's", Source.any, Stat.avg_grd, 36500)]), 
       [0.0, 12700, 33000.0, 0.0, 0.0])
expect(list_of_avg_valid_debt(['Newfoundland and Labrador', 'Manitoba', 'Quebec'], 
                              [StudentDebt('Newfoundland and Labrador', "Bachelor's", Source.any, Stat.avg_grd, 32700),
                               StudentDebt('Quebec', "Bachelor's", Source.any, Stat.avg_grd, 25000),
                               StudentDebt('Quebec', "Bachelor's", Source.any, Stat.avg_grd, 48700),
                               StudentDebt('Quebec', "Doctorate", Source.any, Stat.pct_grd, 30),
                               StudentDebt('Quebec', "Bachelor's", Source.any, Stat.avg_grd, 12700),
                               StudentDebt('Manitoba', "Bachelor's", Source.any, Stat.avg_grd, 22490),
                               StudentDebt('Newfoundland and Labrador', "Bachelor's", Source.any, Stat.avg_grd, 34298)]), 
       [(32700+34298)/2, 22490, (25000+48700+12700)/3])

expect(list_of_avg([], []), [])
expect(list_of_avg(['Manitoba', 'Nova Scotia'], LOSD), [0.0, 0.0])
expect(list_of_avg(['Canada', 'Saskatchewan'], [SD1, SD2, SD3]), [(56+34000)/2, 0.0]) 
expect(list_of_avg(['Ontario', 'Alberta', 'British Columbia'], LOSD), 
       [18950, (12600+20300)/2, 43]) 

expect(avg_debt_in_geo([], 'Manitoba'), 0.0)
expect(avg_debt_in_geo([SD2, SD3], 'Ontario'), 0.0)
expect(avg_debt_in_geo(LOSD, 'Alberta'), (12600+20300)/2)
expect(avg_debt_in_geo(LOSD, 'Quebec'), 31020)

expect(average([]), 0.0)
expect(average([SD1, SD2, SD3]), 15552.0)
expect(average([SD4, SD5, SD6, SD7]), 17578.25)
expect(average(LOSD), 116969/7)

expect(filter_geo([], 'Canada'), [])
expect(filter_geo(LOSD, 'Manitoba'), [])
expect(filter_geo(LOSD, 'Alberta'), [SD3, SD7])
expect(filter_geo(LOSD, 'Ontario'), [SD5])
expect(filter_geo([SD1, SD2], 'Canada'), [SD1, SD2])

expect(is_given_geo(SD1, 'Canada'), True)
expect(is_given_geo(SD3, 'Canada'), False)
expect(is_given_geo(SD4, 'British Columbia'), True)
expect(is_given_geo(SD5, 'Saskatchewan'), False)

expect(filter_valid_debt([]), [])
expect(filter_valid_debt([SD1, SD4, SD5]), [])
expect(filter_valid_debt(LOSD), [SD2, SD3, SD6])
expect(filter_valid_debt([StudentDebt('Alberta', "Bachelor's", Source.any, Stat.avg_intv, 19100),
                          StudentDebt('Prince Edward Island', "Bachelor's", Source.any, Stat.avg_grd, 29500),
                          StudentDebt('Ontario', 'Doctorate', Source.gov, Stat.avg_grd, 28700)]), 
       [StudentDebt('Prince Edward Island', "Bachelor's", Source.any, Stat.avg_grd, 29500)])

expect(is_valid_bachelor_debt(SD1), False)
expect(is_valid_bachelor_debt(SD2), True)
expect(is_valid_bachelor_debt(SD5), False)
expect(is_valid_bachelor_debt(SD7), False)

expect(is_valid_stat(SD1), False)
expect(is_valid_stat(SD2), True)
expect(is_valid_stat(SD3), True)

expect(is_avg_grd(Stat.pct_grd), False)
expect(is_avg_grd(Stat.pct_lrg), False)
expect(is_avg_grd(Stat.pct_paid), False)
expect(is_avg_grd(Stat.avg_grd), True)
expect(is_avg_grd(Stat.avg_intv), False)

expect(is_valid_source(SD1), False)
expect(is_valid_source(SD2), True)
expect(is_valid_source(SD3), True)

expect(is_any_source(Source.gov), False)
expect(is_any_source(Source.non_gov), False)
expect(is_any_source(Source.any), True)

expect(is_bachelor(SD1), False)
expect(is_bachelor(SD2), True)
expect(is_bachelor(SD4), False)

expect(geo_locations([]), [])
expect(geo_locations([StudentDebt('Saskatchewan',"Bachelor's", Source.non_gov, Stat.avg_intv, 17400),
                      StudentDebt('Saskatchewan',"Master's", Source.any, Stat.pct_grd, 42)]), 
       ['Saskatchewan'])
expect(geo_locations([StudentDebt('Canada', 'College', Source.any, Stat.pct_lrg, 16),
                      StudentDebt('Canada', 'College', Source.any, Stat.avg_grd, 12700),
                      StudentDebt('Canada', 'College', Source.any, Stat.avg_grd, 13600),
                      StudentDebt('Newfoundland and Labrador', "Bachelor's", Source.any, Stat.avg_grd, 32700),
                      StudentDebt('Ontario', 'Doctorate', Source.gov, Stat.avg_grd, 28700)]), 
       ['Canada', 'Newfoundland and Labrador', 'Ontario'])
expect(geo_locations([StudentDebt('Alberta', "Bachelor's", Source.any, Stat.avg_intv, 19100),
                      StudentDebt('Prince Edward Island', "Bachelor's", Source.any, Stat.avg_grd, 29500),
                      StudentDebt('Prince Edward Island', "Bachelor's", Source.any, Stat.avg_grd, 36500)]),
       ['Alberta', 'Prince Edward Island'])
expect(geo_locations(LOSD), ['Canada','Alberta','British Columbia', 'Ontario', 'Quebec'])

expect(new_geo([], SD1), True)
expect(new_geo(["Canada", "Alberta"], SD1), False)
expect(new_geo(["Nova Scotia", "Ontario"], SD4), True)
expect(new_geo(['Prince Edward Island', "Quebec", "Alberta"], SD6), False)

summary()

"""## **FINAL GRAPH**"""

main("student_debt_by_province_and_level_of_study.csv")

"""*Below are the actual values just for reference:*"""

import pandas as pd
loc=geo_locations(read("student_debt_by_province_and_level_of_study.csv"))
debt=list_of_avg_valid_debt(loc, read("student_debt_by_province_and_level_of_study.csv")) 
pd.DataFrame({
    'Locations': loc,
    'Debt Amount': debt
})
